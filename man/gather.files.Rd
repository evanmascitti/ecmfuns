% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gather.files.r
\name{gather.files}
\alias{gather.files}
\title{\lifecycle{experimental}}
\usage{
gather.files(dir = ".", extension = NULL, recursive = FALSE)
}
\arguments{
\item{dir}{Relative path to directory where the files reside (includes the
trailing \code{/}). For .Rmd files this begins at the same level as the .Rmd
file, which is usually good but can be annoying when the file you need to
read resides above the .Rmd file in the directory structure. In this case
you can look one directory upward with \verb{/..} or to the top-level directory with
\code{/}.}

\item{extension}{quoted file extension, accepts 3-letter extension with OR
without a preceding "." Verify capitalization.}

\item{recursive}{whether to search sub-directories}
}
\value{
A named character vector of file paths to read. The element names are
the base file names with the file extension stripped.
}
\description{
Prepare a set of files to be iteratively read into R
}
\details{
This is a helper function to remove friction and reduce eyesore when reading
multiple data files in one step. A base method with \code{list.files()} works fine
but requires more arguments than I want to remember for this very common task.
This wrapper cleans the path strings to assign nice names to the files as they
are imported.

Output is easily piped to \code{\link[=read.files]{read.files()}} to read the files and
compile them in a tibble. Because \code{gather.files} gives nice names to its
elements, the list is more human-readable.
}
\examples{
 \dontrun{
gather.files(dir = "data/raw_data/2020-10-25_Atterberg_limits",
extension= ".csv")}


}
